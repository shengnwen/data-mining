That reader has a pretty strong idea, already, of how computers and compilers work, and is ready for a different kind of view. There are a few valuable differences here, compared to most discussions. The first is its emphasis on embedded systems. Loosely speaking, that's any computer that doesn't look like a computer: anti-lock brakes, iPods, microwave ovens, or the processor[s] internal to disk drives. Ignoring the tiny fraction with keyboards and screens, that's pretty much all of computing. The second distinctive feature of this book's viewpoint is it emphasis on the computer as a whole, including cooperating SoC components, operating systems and such, power management, and the instruction set processor itself. Programmers from the Windows/Unix world may be startled by the idea that the instruction set and processor data paths are variables, adjustable to the task at hand. The book's emphasis on close system integration follows the consequences of custom instruction sets out through the simulators, linkers, and compilers that put the processor to work. The authors offer wide-ranging and hard-won insight into optimization techniques, giving glimpses at the scars these project-hardened veterans have picked up along the way.

The book's most distinctive feature, however, is its emphasis on Very Long Instruction Word (VLIW) processors. These come in many flavors. One classic structure comes from TI's DSPs with 8 ALUs controlled in every cycle; standard superscalar and Intel's EPIC are also noted, for contrast and variety. The book is thick (over 600pp) and dense, so no summary can do it justice and still fit here. 

The book's personal note is part of its charm. The authors aren't afraid to take on widespread opinoins in their "Flame" sidebars. One in particular struck home for me: the polite diatribe against "smart" assemblers that hide the machine from the people who really need to see it. Amen, brother! My worst experience of that sort was in the 90s-era TI C5x family. It had delayed branches, with two words in the delay slot. You could put either two one-word instructions or one two-word instruction into that slot. After annoyance that you can imagine, I discovered that the compiler was putting a one-word instruction in the branch shadow followed by a two-word instruction. It was executing one and a half instructions in the branch delay, with un-helpful effect. That second instruction was the one the assembler was "helping" with. If the immediate operand had been smaller, it would have been a one-word instruction and would have been fine. The immediate value was too big, though, so the assembler converted that same opcode into a different two-word machine instruction with a larger immediate field - kaboom!

It's a good survey and a good introduction for people who want a wider view of what computing is about. Given the rise of reconfigurable computing, it's also helpful in putting readers in the frame of mind needed for defining their own computers as a matter of course. The breadth of coverage means that, despite the book's mass, its coverage of some topics lacks depth. I can't really fault the authors, though, since there's so much to say and since different readers have such different needs. The depth is there, but it's in the exercises and copious references so readers have to dig into it on their own. This isn't a book for every reader, but it's a helpful compendium for people with many kinds of needs a bit away from what computer science usually offers.

//wiredweir

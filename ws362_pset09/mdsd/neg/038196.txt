Perhaps I should forgive Thompson his tender age for the grievous philosophic error he commits as soon as he puts pen to paper, to wit, neither is functional programming new nor is Haskell its foremost exemplar. (Curiously, one Dr. Haskell was my orthodontist when I was a little boy, which rang a soft little bell deep in my cerebrum.) As far as functional programming is concerned, LISP is the way, the truth, and the light. Haskell may do more by way of notational "syntactic sugar" than LISP--with certainty, it can be hard to express yourself graphically when limited to concretely mathematically grounded notations [LISP = L(ots) of I(ncredibly) S(tupid) P(arentheses)]. Notwithstanding, I contend that the more difficult exercises that Thompson introduces--putatively as a vehicle for showcasing the brilliance of Haskell--point in quite the opposite direction. For LISP allows, nay encourages, parallel top-down/bottom-up development whereby you carefully extend the language to create, shall we say, a meta-4GL atop which to code your application, whereas Haskell will have none of this: it is a run-of-the-mill 3GL with some concepts and quirks that may be unfamiliar to the less sophisticated programmer, nor less, nor more. Nay, nay, I speedily toss Haskell into the basket that houses nearly every new language that comes down the pike: a few new tidbits perhaps; a more tersely expressed concept perchance; but nothing new to the sophisticate whose grasp of computer language (not to mention compuer languageS) extends beyond the ALGOL family (and, by extension, its somewhat more capable analogues, e.g., C, Java) and the handier "scripting" languages (e.g., Python, Ruby, Perl) that attempt to marry some OO concepts into what is ultimately a procedural substrate. Kids, first learn what a computer system is; learn assembly language on six or seven processors and how it relates to their bus architecture, I/O interface (e.g., whether DMA or "programmed" [a la the R6502: an admittedly poor term]) and microinstruction decoding; study LISP, APL, FORTRAN 66, SNOBOL, and other vehicles that enable you to explore the range of man's machinewise thinking beyond simple-minded von Neumann and MIX models that calculate the contents of address 1 based upon the contents of address 2; THEN, and only then, read and comment upon a Haskell text
